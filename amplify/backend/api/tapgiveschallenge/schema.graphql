# Key notes:
# 1. Customer->site one to one
# 2. Customers can only have one subscription right now (can be changed by making it a composite key)

# Has Duplicates to allow for better queries (composite of id/site)
type SiteManager @model @auth(rules:[{ allow: private, operations:[read] }
    {allow: groups, groups:["Admins"]}]) {
    id: ID! @primaryKey(sortKeyFields: ["siteID"]) @index(name: "bySiteManagerID", queryField: "siteManagerByID")
    siteID: ID! @index(name: "bySite", queryField: "siteManagerBySite") # Site ID, must be scalar to be a sort key
    site: Site @belongsTo(fields:["siteID"])
    phoneNumber: String!
}

# DynamoDB streams for transactions
type Customer @model @auth(rules:[{ allow: private}]) {
    IDNumber: ID! @primaryKey # (sortKeyFields: ["siteID"]) @index(name: "byCustomerID", queryField: "customerByID")  This is to make it composite
    siteID: ID! @index(name: "bySite", queryField: "customerBySite")# Site ID, must be scalar to be a sort key
    site: Site @hasOne(fields:["siteID"])
    validSubscription: String!
    pin: Int!
    phoneNumber: String!
    firstName: String!
    lastName: String!
    language: String!
    expiration: String
}
# DynamoDB streams->Lambda to log status changes
type Site @model @auth(rules:[{ allow: private, operations:[read] }
    {allow: groups, groups:["Admins"]}]) {
    id: ID! # not used to query
    siteManagers: [SiteManager] @hasMany
    name: String!
    nickname: String! # Short code, can be queried
    description: String # Can be error message too (?) error can be abstracted away
    serviceRadius: Float! # Measured in KM
    latitude: Float!
    longitude: Float!
    averageWait: Int! # Measured in minutes
    averageLine: Int! # Measured in people
    status: String! # Change to type
    estimatedDaily: Int! # Estimation using average of last 30 days?
    subscriptionFee: Float!
    expectedJerrycans: Int!
}

type Language @model @auth(rules: [{allow: public, provider: iam, operations: [read]}
    {allow: private}]) {
    id: ID! # the "code", eg "en"
    language: String! # language, eg "English"
}

type Phrase @model @auth(rules: [{allow: public, provider: iam, operations: [read]}
    {allow: private}]) {
    id: ID! @primaryKey(sortKeyFields: ["languageID"]) # phrase, eg. passwordField
    languageID: ID! @index(name: "byLanguage", queryField: "phraseByLanguage") # language ID, must be scalar to be a sort key
    language: Language @hasOne(fields:["languageID"])
    data: String! # eg. password
}
# DynamoDB streams->Lambda to process data
type Visit @model @auth(rules:[{ allow: private}]) {
    id: ID! @primaryKey
    customerID: ID! @index(name: "visitByCustomerID", queryField: "visitByCustomerID")
    siteID: ID! @index(name: "bySite", queryField: "visitBySite") # site ID, must be scalar to be a sort key
    timeStamp: String!
}
