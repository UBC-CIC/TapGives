# Key notes:
# 1. Customer->site one to one
# 2. Customers can only have one subscription right now (can be changed by making it a composite key)

# Has Duplicates to allow for better queries (composite of id/site)
type SiteManager @model @auth(rules:[{ allow: private, operations:[read] }
    {allow: groups, groups:["Admins"]}]) {
    id: ID! @primaryKey(sortKeyFields: ["siteID"]) @index(name: "bySiteManagerID", queryField: "siteManagerByID")
    siteID: ID! @index(name: "bySite", queryField: "siteManagerBySite") # Site ID, must be scalar to be a sort key
    site: Site @belongsTo(fields:["siteID"])
    phoneNumber: String! # eg. +2549991234
}

# DynamoDB streams for transactions
type Customer @model @auth(rules:[{ allow: private}]) {
    id: ID!
    governmentID: ID! @index(name: "byGovernmentID", queryField: "customerByGovernmentID") # givernment issued ID
    siteID: ID! @index(name: "bySite", queryField: "customerBySite")# Site ID, must be scalar to be a sort key
    site: Site @hasOne(fields:["siteID"])
    validSubscription: String! # true, false, pending?
    pin: Int!
    phoneNumber: String! @index(name: "byPhoneNumber", queryField: "customerByPhoneNumber")
    firstName: String! @index(name: "byFirstName", queryField: "customerByFirstName")
    lastName: String!
    preferredLanguage: String!
    subscriptionExpiration: String! # ISO 8601 (AWS timestamp)
}
# DynamoDB streams->Lambda to log status changes
type Site @model @auth(rules:[{ allow: private, operations:[read] }
    {allow: groups, groups:["Admins"]}]) {
    id: ID!
    siteManagers: [SiteManager] @hasMany
    name: String!
    nickname: String! # Short code, can be queried
    description: String # Can be error message too (?) error can be abstracted away
    serviceRadius: Float! # Measured in KM
    latitude: Float!
    longitude: Float!
    avgWaitMinute: Int! # Measured in minutes
    avgLineCount : Int! # Measured in people
    status: String! # online, maintenance, offline
    subscriptionFee: Float!
    expectedJerrycans: Int!
}

type Language @model @auth(rules: [{allow: public, provider: iam, operations: [read]}
    {allow: private}]) {
    id: ID! # the "code", eg "en"
    language: String! # language, eg "English"
}

type Phrase @model @auth(rules: [{allow: public, provider: iam, operations: [read]}
    {allow: private}]) {
    id: ID! @primaryKey(sortKeyFields: ["languageID"]) # phrase, eg. passwordField
    languageID: ID! @index(name: "byLanguage", queryField: "phraseByLanguage") # language ID, must be scalar to be a sort key
    language: Language @hasOne(fields:["languageID"])
    data: String! # eg. password
}
# DynamoDB streams->Lambda to process data
type CustomerTransactions @model @auth(rules:[{ allow: private, operations:[read] }
    {allow: groups, groups:["Admins"]}]) {
    id: ID! @primaryKey
    userPhoneNumber: String! @index(name: "byPhoneNumber", queryField: "customerTransactionByPhoneNumber")
    fullName: String! # firstName+" "+lastName
    siteName: String!
    siteID: ID! @index(name: "bySite", queryField: "customerTransactionBySite")
    action: String!
    collectedJerryCans: Int!
    timeStamp: String! # ISO 8601 (AWS timestamp)
}
