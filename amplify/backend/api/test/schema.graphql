# Designed to be compatable with Datastore
# Key notes:
# 1. primary keys MUST be id: ID!

# Issues
# 1. Datastore continually being enabled will prevent some queries.
# 2. GraphQL's method of calling dynamoDB does not allow for efficient tables (https://www.alexdebrie.com/posts/dynamodb-single-table/#downsides-of-a-single-table-design)

# Has Duplicates to allow for better queries (composite of id/site)
type SiteManager @model @auth(rules:[{ allow: private }]) {
    id: ID! @primaryKey(sortKeyFields: ["site"])
    name: String!
    site: ID! # Site ID, must be scalar to be a sort key
}

# Has Duplicates to allow for better queries (composite of id/site)
type Customer @model @auth(rules:[{ allow: private }]){
    id: ID! @primaryKey(sortKeyFields: ["site"])
    site: ID! # Site ID, must be scalar to be a sort key
    sub: Sub @hasOne
    pin: Int!
    phoneNumber: String!
    name: String!
}

type Site @model @auth(rules:[{ allow: private }]) {
    id: ID!
    subs: [Sub]! @hasMany
    siteManagers: [SiteManager] @hasMany
    name: String!
    description: String # Can be error message too (?) error can be abstracted away
    serviceRadius: Float! # Measured in KM
    latitude: Float!
    longitude: Float!
    averageWait: Int! # Measured in seconds
    averageLine: Int! # Measured in people
    online: Boolean!
    estimatedDaily: Int! # Estimation using average of last 30 days?
}

# Perhaps some description would be nice for future reference
type Sub @model @auth(rules:[{ allow: private }]) {
    id: ID!
    site: Site! @belongsTo
    name : String!
    pricePerMonth: Float!
    weeklyJerryCans: Int!
}

type Language @model @auth(rules: [{allow: public, provider: iam, operations: [read]}
    {allow: private}]) {
    id: ID!
    code: String!
    language: String!
}

type Phrase @model @auth(rules: [{allow: public, provider: iam, operations: [read]}
    {allow: private}]) {
    id: ID!
    code: String!
    phrase: String!
    data: String!
}